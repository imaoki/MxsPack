/*! Â© 2022 imaoki | MIT License | https://github.com/imaoki */;(local hasMetRequirements;fn hasMetRequirements = (isStruct ::std and isProperty ::std #StructName and classOf ::std.StructName == MAXScriptFunction and ::std.StructName() == #StandardStruct;);if not hasMetRequirements() do (local fileClass = DotNetClass "System.IO.File";local pathClass = DotNetClass "System.IO.Path";local currentDir = pathClass.GetDirectoryName (getSourceFileName());local standardFile = currentDir + @"\Standard.min.ms";if fileClass.Exists standardFile do fileIn standardFile;);if not hasMetRequirements() do (format "[error]Requirement not met.\n";););struct MxsPackStruct (public _CP1_,private blankLineRegex,private blockCommentRegex,private commaBreakRegex,private continuationLineRegex,private indentationRegex,private installerRegex,private lfRegex,private lineCommentRegex,private pathUtility,public fn AppendText source input = (local result = undefined;if classOf source == String and classOf input == String do (result = source + input;);result;),public fn ClipFile path fromPos stringLength = (local result = undefined;if this.isValidPathUtility this.pathUtility and classOf fromPos == Integer and classOf stringLength == Integer and fromPos > 0 and stringLength != 0 do (local fullPath = this.pathUtility.GetFullPath path;local code = ::std.FileUtility.ReadAllText fullPath;if classOf code == String do (if stringLength < 0 do (stringLength = code.Count - fromPos + 1;);if code.Count >= fromPos + stringLength - 1 do (result = substring code fromPos stringLength;);););result;),public fn ClipText source fromPos stringLength = (local result = undefined;if classOf source == String and classOf fromPos == Integer and classOf stringLength == Integer and fromPos > 0 and stringLength != 0 do (if stringLength < 0 do (stringLength = source.Count - fromPos + 1;);if source.Count >= fromPos + stringLength - 1 do (result = substring source fromPos stringLength;););result;),public fn CopyDirectory source destination = (if this.isValidPathUtility this.pathUtility do (local srcFullPath = this.pathUtility.GetFullPath source;local destFullPath = this.pathUtility.GetFullPath destination;::std.FileUtility.CopyDirectory srcFullPath destFullPath overwrite:true;format "[copy]@\"%\"\n" destFullPath;);ok;),public fn DeleteDirectory path = (if this.isValidPathUtility this.pathUtility do (local fullPath = this.pathUtility.GetFullPath path;::std.FileUtility.DeleteDirectory fullPath recursive:true;format "[delete]@\"%\"\n" fullPath;);ok;),public fn InsertText source insertPos input = (local result = undefined;if classOf source == String and classOf insertPos == Integer and insertPos > 0 and classOf input == String do (if insertPos > source.Count then (result = this.AppendText source input;);else (if insertPos == 1 then (result = input + source;);else (result = replace source insertPos 0 input;);););result;),public fn Install = (if isProperty ::startupLoader #RegisterFile do (::startupLoader.RegisterFile (getSourceFileName()););format "[install]::MxsPackStruct\n";ok;),public fn Minify input = (local result = undefined;if classOf input == String do (result = copy input;if this.continuationLineRegex.IsMatch result do (result = this.continuationLineRegex.Replace result " ";);if this.blockCommentRegex.IsMatch result do (result = this.blockCommentRegex.Replace result "";);if this.lineCommentRegex.IsMatch result do (result = this.lineCommentRegex.Replace result "";);if this.blankLineRegex.IsMatch result do (result = this.blankLineRegex.Replace result "";);if this.indentationRegex.IsMatch result do (result = this.indentationRegex.Replace result "";);if this.commaBreakRegex.IsMatch result do (result = this.commaBreakRegex.Replace result "";);if this.lfRegex.IsMatch result do (result = this.lfRegex.Replace result ";";););result;),public fn RemoveInstallerOption input = (local result = undefined;if classOf input == String and this.installerRegex.IsMatch input do (result = this.installerRegex.Replace input "";);result;),public fn ReplaceText source fromPos stringLength input = (local result = undefined;if classOf source == String and classOf fromPos == Integer and classOf stringLength == Integer and fromPos > 0 and stringLength != 0 and classOf input == String do (if stringLength < 0 do (stringLength = source.Count - fromPos + 1;);if source.Count >= fromPos + stringLength - 1 do (result = replace source fromPos stringLength input;););result;),public fn Uninstall = (if isProperty ::startupLoader #UnregisterFile do (::startupLoader.UnregisterFile (getSourceFileName()););format "[uninstall]::MxsPackStruct\n";ok;),public fn WriteAllText path contents = (if this.isValidPathUtility this.pathUtility do (local fullPath = this.pathUtility.GetFullPath path;local dirPath = this.pathUtility.GetDirectoryName fullPath;if not ::std.FileUtility.DirectoryExists dirPath do (::std.FileUtility.CreateDirectory dirPath;);if ::std.FileUtility.DirectoryExists dirPath do (::std.FileUtility.WriteAllText fullPath contents;format "[write]@\"%\"\n" fullPath;););ok;),private fn isValidPathUtility obj = (isStruct obj and isProperty obj #StructName and classOf obj.StructName == MAXScriptFunction and obj.StructName() == #PathUtilityStruct;),private version = "1.0.0",public fn StructName = #MxsPackStruct,public fn Dump indent:"" out:listener = (format "%MxsPackStruct\n" indent to:out;if this.isValidPathUtility this.pathUtility then (format "%  pathUtility:\n" indent to:out;this.pathUtility.Dump indent:(indent + "    ") out:out;);else (format "%  pathUtility:%\n" indent this.pathUtility to:out;);ok;),public fn Equals obj = (local isEqualStructName = isStruct obj and isProperty obj #StructName and classOf obj.StructName == MAXScriptFunction and obj.StructName() == this.StructName();local isEqualProperties = true;isEqualStructName and isEqualProperties;),public fn GetVersion = (this.version;),on Create do (if classOf this._CP1_ == String do (if ::std.FileUtility.DirectoryExists this._CP1_ or ::std.FileUtility.FileExists this._CP1_ do (this.pathUtility = ::std.PathUtilityStruct this._CP1_;););this.blankLineRegex = ::std.StringUtility.CreateRegex "^ *?\n" options:#(#IgnoreCase, #Multiline);this.blockCommentRegex = ::std.StringUtility.CreateRegex "^ */\*(?!!)(.|\n)*?\*/\n?" options:#(#IgnoreCase, #Multiline);this.commaBreakRegex = ::std.StringUtility.CreateRegex "(?<=\(|,)\n" options:#(#IgnoreCase, #Multiline);this.continuationLineRegex = ::std.StringUtility.CreateRegex " *\\\\ *\n *" options:#(#IgnoreCase, #Multiline);this.indentationRegex = ::std.StringUtility.CreateRegex "^ +" options:#(#IgnoreCase, #Multiline);this.installerRegex = ::std.StringUtility.CreateRegex "(?<=\.RegisterFile \(getSourceFileName\(\)\)) installer:true" options:#(#IgnoreCase, #Multiline);this.lfRegex = ::std.StringUtility.CreateRegex "\n" options:#(#IgnoreCase, #Multiline);this.lineCommentRegex = ::std.StringUtility.CreateRegex "^ *--.*?\n" options:#(#IgnoreCase, #Multiline);););::MxsPackStruct.Install();::MxsPackStruct;